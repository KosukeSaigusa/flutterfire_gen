# Annotations for Fields

When defining the schema for Cloud Firestore documents with the `flutterfire_gen` package, you can customize the behavior of code generation for each field by applying various annotations.

## Annotations to Set Default Values

The `flutterfire_gen` package generates different processes optimized for reading, creating, updating (and deleting) operations. Default values can also be set separately for each of these operations.

### Setting Default Values for Reading

Default values for reading are set using the `@ReadDefault` annotation.

Below, the `isCompleted` field of the document in the `todos` collection is annotated with `@ReadDefault(false)`.

This means that when reading a `todo` document, if `isCompleted` is `null`, `false` is stored instead.

```dart title="todo.dart"
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutterfire_gen_annotation/flutterfire_gen_annotation.dart';

part 'todo.flutterfire_gen.dart';

@FirestoreDocument(path: 'todos/{todoId}')
class Todo {
  const Todo({
    required this.isCompleted,
  });

  @ReadDefault(false)
  final bool isCompleted;
}
```

The `isCompleted` field is convenient when it's possible to be `null` in the Cloud Firestore document but you want to treat it as a non-nullable `bool` type in Flutter/Dart, using `false` in case of `null`.

### Setting Default Values for Creation

Default values for creation are set using the `@CreateDefault` annotation.

Below, the `value` field of the document in the `counters` collection is annotated with `@CreateDefault(0)`.

This means that when creating a `counter` document, if `value` is not specified, `0` is stored.

```dart title="counter.dart"
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutterfire_gen_annotation/flutterfire_gen_annotation.dart';

part 'counter.flutterfire_gen.dart';

@FirestoreDocument(path: 'counters/{counterId}')
class Counter {
  const Counter({
    required this.value,
  });

  @CreateDefault(0)
  final int value;
}
```

For example, if you create a document in the `counters` collection using the `CreateCounter` interface without specifying a `value`, the `value` field will be created as `0`.

```dart
final query = CounterQuery();
final DocumentReference<CreateCounter> documentReference =
    await query.add(createCounter: const CreateCounter());
```

Of course, you can also specify a value for the `value` field, and in that case, the specified value will be stored.

```dart
final query = CounterQuery();
final DocumentReference<CreateCounter> documentReference =
    await query.add(createCounter: const CreateCounter(value: 1));
```

### Setting Default Values for Update

Default values for update are set using the `@UpdateDefault` annotation.

Below, the `isEdited` field of the document in the `messages` collection is annotated with `@UpdateDefault(true)`.

This means that when updating a `message` document, if `isEdited` is not specified, `true` is stored.

```dart title="message.dart"
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutterfire_gen_annotation/flutterfire_gen_annotation.dart';

part 'message.flutterfire_gen.dart';

@FirestoreDocument(path: 'messages/{messageId}')
class Message {
  const Message({
    required this.content,
    required this.value,
  });

  final String content,

  @UpdateDefault(true)
  final bool isEdited;
}
```

For example, if you update a document in the `messages` collection using the `UpdateMessage` interface without specifying an `isEdited` value, the `isEdited` field will be updated as `true`.

```dart
final query = MessageQuery();
await query.update(
  messageId: 'messageId',
  updateMessage: const UpdateMessage(
    content: 'An updated content',
  ),
);
```

You can also specify a value for the `isEdited` field, and in that case, the specified value will be stored.

```dart
final query = MessageQuery();
await query.update(
  messageId: 'messageId',
  updateMessage: const UpdateMessage(
    content: 'An updated content',
    isEdited: false,
  ),
);
```

## Annotations for Writing with FieldValue

When creating or updating Cloud Firestore documents, you can use `FieldValue` in addition to specifying actual values to be stored.

With the `flutterfire_gen` package, you can generate code that supports writing with `FieldValue`.

To use `FieldValue` in the code generated by `flutterfire_gen`, you need to import the `flutterfire_gen_utils` package.

```diff
import 'package:cloud_firestore/cloud_firestore.dart';
+ import 'package:flutterfire_gen_utils/flutterfire_gen_utils.dart';
import 'package:flutterfire_gen_annotation/flutterfire_gen_annotation.dart';

part 'counter.flutterfire_gen.dart';

/** omitted */
```

The `value` field of the document in the `counters` collection is annotated with `@allowFieldValue` to allow writing with actual integers or `FieldValue`.

```dart title="counter.dart"
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutterfire_gen_utils/flutterfire_gen_utils.dart';
import 'package:flutterfire_gen_annotation/flutterfire_gen_annotation.dart';

part 'counter.flutterfire_gen.dart';

@FirestoreDocument(path: 'counters/{counterId}')
class Counter {
  const Counter({
    required this.value,
  });

  @allowFieldValue
  final int value;
}
```

To update the `value` field of the `counters` collection with an actual value (e.g., `1`), provide an `ActualValue` type.

```dart
final query = CounterQuery();
await query.update(
  counterId: 'counterId',
  updateCounter: const UpdateCounter(value: ActualValue<int>(1)),
);
```

To update the `value` field of the `counters` collection by incrementing the current value by `1`, provide a `FieldValueData` type.

```dart
final query = CounterQuery();
await query.update(
  counterId: 'counterId',
  updateCounter: UpdateCounter(value: FieldValueData(FieldValue.increment(1))),
);
```

Although the `Counter` class defines the `value` field as a simple `int` type, the `flutterfire_gen` package generates separate processes and interfaces optimized for reading, creating, updating (and deleting) operations. By applying the `@allowFieldValue` annotation to the target field, it is possible to support writing with `FieldValue`.

## Annotations to Automatically Use Server Time for Writing

When creating or updating documents, it's often desired to automatically apply server time to fields like `createdAt` or `updatedAt`.

Using `FieldValue.serverTimestamp()`, you can automatically apply server time, but with the `flutterfire_gen` package, you can implement interfaces without considering it by applying `@alwaysUseFieldValueServerTimestampWhenCreating` or `@alwaysUseFieldValueServerTimestampWhenUpdating` annotations.

For example, below is the schema definition for the `todos` collection documents.

```dart title="todo.dart"
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutterfire_gen_annotation/flutterfire_gen_annotation.dart';

part 'todo.flutterfire_gen.dart';

@FirestoreDocument(path: 'todos/{todoId}')
class Todo {
  const Todo({
    required this.title,
    required this.createdAt,
    required this.updatedAt,
  });

  final String title;

  @alwaysUseFieldValueServerTimestampWhenCreating
  final DateTime? createdAt;

  @alwaysUseFieldValueServerTimestampWhenCreating
  @alwaysUseFieldValueServerTimestampWhenUpdating
  final DateTime? updatedAt;
}
```

When creating a document in the `todos` collection using the `CreateTodo` interface, there's no need to apply `createdAt` or `updatedAt`. The generated code will automatically apply `FieldValue.serverTimestamp()` internally.

```dart
final query = TodoQuery();
final DocumentReference<CreateTodo> documentReference = await query.add(
  createTodo: const CreateTodo(title: 'A new todo title'),
);
```

Similarly, when updating a document in the `todos` collection using the `UpdateTodo` interface, there's no need to apply `updatedAt`. The generated code will automatically apply `FieldValue.serverTimestamp()` internally.

The `createdAt` field can be updated with the desired value, as it does not have the `@alwaysUseFieldValueServerTimestampWhenUpdating` annotation applied.

```dart
final query = TodoQuery();
await query.update(
  todoId: 'todoId',
  updateTodo: UpdateTodo(
    title: 'An updated todo title',
    createdAt: DateTime(1970),
  ),
);
```

Also, the conversion between the Dart `DateTime` type and the Cloud Firestore `Timestamp` type typically requires the application of a `JsonConverter`, but the `flutterfire_gen` package automatically handles this conversion.

## Annotations to Apply JsonConverter

With the `flutterfire_gen` package, you can use `JsonConverter` to convert between types handled in Dart and those in Cloud Firestore.

Please add the `json_annotation` package to your `pubspec.yaml` beforehand.

```yaml title="pubspec.yaml"
dependencies:
  json_annotation:
```

For how to use it, see [json_annotation](https://pub.dev/packages/json_annotation).

## Annotations to Apply JsonPostProcessor

ðŸš§ðŸš§ðŸš§ Under Preparation ðŸš§ðŸš§ðŸš§
